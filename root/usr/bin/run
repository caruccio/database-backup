#!/bin/bash

COLOR_GREEN="\e[32m"
COLOR_CYAN="\e[96m"
COLOR_GRAY="\e[90m"
COLOR_RED="\e[31m"
COLOR_RESET="\e[0;0m"

[ "${DEBUG}" == 1 ] && set -x
unset DEBUG

TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)

is_database()
{
    oc rsh -n $1 $2 <${CONTAINER_SCRIPTS_PATH}/check-database &>/dev/null
}

send_to_azure()
{
   [ -n "${AZURE_ACCOUNT_KEY}" ] && \
   [ -n "${AZURE_ACCOUNT_NAME}" ] && \
   [ -n "${AZURE_CONTAINER}" ]
}


send_to_aws()
{
   [ -n "${AWS_ACCESS_KEY_ID}" ] && \
   [ -n "${AWS_SECRET_ACCESS_KEY}" ] && \
   [ -n "${AWS_S3_BUCKET_NAME}" ] && \
   [ -n "${AWS_REGION}" -o -n "${AWS_DEFAULT_REGION}" ]
}

send_to_gce()
{
   [ -n "${GOOGLE_APPLICATION_CREDENTIALS}" ] && \
   [ -n "${GOOGLE_BUCKET_NAME}" ]
}

azure_upload()
{
    echo -e "${COLOR_CYAN}--> Uploading to Azure Blob Storage: ${AZURE_CONTAINER}/$1${COLOR_RESET}"
    ${CONTAINER_SCRIPTS_PATH}/upload-azure "${1}"
}


aws_upload()
{
    echo -e "${COLOR_CYAN}--> Uploading to AWS S3: s3://$AWS_S3_BUCKET_NAME/$1"
    ${CONTAINER_SCRIPTS_PATH}/upload-aws "${1}"
}

gce_upload()
{
    echo -e "${COLOR_CYAN}--> Uploading to GCE Bucket: $GOOGLE_BUCKET_NAME/$1$"
    trap "rm -vf ${1}" EXIT
    echo -e "--> Creating temporary file $1$"
    mkdir -p "${1%/*}"
    cat > "${1}"
    ${CONTAINER_SCRIPTS_PATH}/upload-gce "${1}"
    echo -ne "${COLOR_RESET}"
}


upload()
{
    local namespace=${1}
    local prefix=${2//\//-}
    local extension=${3:-}
    local namespace_uid=$(oc get namespaces/$namespace -o template --template='{{.metadata.uid}}')
    local remote_path="database/${namespace,,}/${namespace_uid^^}/${prefix,,}-${TIMESTAMP^^}${extension,,}"

    if send_to_azure; then
        azure_upload "${remote_path}"
    elif send_to_aws; then
        aws_upload "${remote_path}"
    elif send_to_gce; then
        gce_upload "${remote_path}"
    fi
}

send_to_azure || send_to_aws || send_to_gce || has_valid_config=0 && has_valid_config=1

if [ $has_valid_config -ne 1 ]; then
    echo -ne "${COLOR_RED}"
    cat <<-EOF
	ERROR: Please select one storage method by settings according env vars:
	ERROR:
	ERROR:  - Azure Blob Storage
	ERROR:      AZURE_ACCOUNT_NAME
	ERROR:      AZURE_ACCOUNT_KEY
	ERROR:      AZURE_CONTAINER
	ERROR:
	ERROR:  - AWS S3
	ERROR:      AWS_ACCESS_KEY_ID
	ERROR:      AWS_SECRET_ACCESS_KEY
	ERROR:      AWS_S3_BUCKET_NAME
	ERROR:      AWS_REGION or AWS_DEFAULT_REGION (optional)
	ERROR:
	ERROR:  - GCE Bucket
	ERROR:      GOOGLE_APPLICATION_CREDENTIALS
	ERROR:      GOOGLE_BUCKET_NAME
	EOF
    echo -e "${COLOR_RESET}"
    exit 1
fi

# set up configuration for openshift client
MASTER_URL=${MASTER_URL:-https://kubernetes.default.svc.cluster.local:443}
MASTER_CA=${MASTER_CA:-/var/run/secrets/kubernetes.io/serviceaccount/ca.crt}
TOKEN_FILE=${TOKEN_FILE:-/var/run/secrets/kubernetes.io/serviceaccount/token}

{
# craft a kubeconfig, usually at $KUBECONFIG location
[ -e "${MASTER_CA}" -a -e "${MASTER_URL}" ] &&
    oc config set-cluster master \
        --certificate-authority="${MASTER_CA}" \
        --server="${MASTER_URL}" || true

[ -e "${TOKEN_FILE}" ] &&
    oc config set-credentials account \
        --token="$(<${TOKEN_FILE})" || true

} >/dev/null

resources=(
    $(oc get deployments --all-namespaces -o template \
        --template="{{range .items}}{{.metadata.namespace}}/{{.kind}}/{{.metadata.name}} {{end}}" \
        ${LABEL_SELECTOR:+-l ${LABEL_SELECTOR}} || true)
    $(oc get deploymentconfigs --all-namespaces -o template \
        --template="{{range .items}}{{.metadata.namespace}}/{{.kind}}/{{.metadata.name}} {{end}}" \
        ${LABEL_SELECTOR:+-l ${LABEL_SELECTOR}} || true)
    $(oc get statefulsets --all-namespaces -o template \
        --template="{{range .items}}{{.metadata.namespace}}/{{.kind}}/{{.metadata.name}} {{end}}" \
        ${LABEL_SELECTOR:+-l ${LABEL_SELECTOR}} || true)
    $(oc get petsets --all-namespaces -o template \
        --template="{{range .items}}{{.metadata.namespace}}/{{.kind}}/{{.metadata.name}} {{end}}" \
        ${LABEL_SELECTOR:+-l ${LABEL_SELECTOR}} || true)
    $(oc get daemonset --all-namespaces -o template \
        --template="{{range .items}}{{.metadata.namespace}}/{{.kind}}/{{.metadata.name}} {{end}}" \
        ${LABEL_SELECTOR:+-l ${LABEL_SELECTOR}} || true)
)

if [ ${#resources[*]} -lt 1 ]; then
    echo -e "${COLOR_RED}--> No suitable applications to dump.${COLOR_RESET}"
    exit 0
fi

echo -e "${COLOR_GREEN}--> Found ${#resources[*]} resources${COLOR_RESET}"

for resource in ${resources[*]}; do
    ns=${resource%%/*}
    resource=${resource#*/}

    if ! is_database ${ns} ${resource}; then
        echo -e "${COLOR_GRAY}--> Ignoring non-database $resource from namespace $ns${COLOR_RESET}"
        continue
    fi

    echo -e "${COLOR_GREEN}--> Dumping ${resource} from namespace $ns"

    oc rsh -n ${ns} ${resource} <${CONTAINER_SCRIPTS_PATH}/dump-database |
        gzip -c - |
        pv --interval 5 --format '%b %t %r' |
        upload $ns ${resource} .gz

    ret=$?
    echo -ne "${COLOR_RESET}"

    if [ $ret -eq 1 ]; then
        echo -e "${COLOR_RED}ERROR: Fail generating backup for $resource from namespace $ns${COLOR_RESET}"
    elif [ $ret -eq 2 ]; then
        echo -e "${COLOR_RED}ERROR: Fail uploading backup for $resource from namespace $ns${COLOR_RESET}"
    fi
done

echo -e "${COLOR_GREEN}--> Finished${COLOR_RESET}"
